<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>_Primitive</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize the data for this subsector

//a subsector is a convex space with a number of textures equal to the number of vertexes plus 2.
//these are nominally supposed to work like Doom subsectors and segs rolled into one.

//NOTE: the textures[] array expects references to backgrounds,
//through the global.TextureReference ds_map.
//TODO: change this object to retrieve texture references on its own (?).
//TODO: collision detection.

sprite_index = blanks;

temp        = 0;        //internal use

//3d dimensions data
numvertexes = 0;        //we cannot have fewer than 4 vertexes per subsector
z1          = 0;
z2          = 0;        //z2 must be &gt; z1 &gt;= 0

//sanity checking
if(numvertexes &lt; 4) {
    I_Quit("Renderer: Tried to create an invalid subsector");
}

if(z1 &gt; z2 || !z2 || z2 &gt; 256) {
    I_Quit("Renderer: Tried to create an invalid subsector");
}

//checks done, create the data
//this section is a holdover, it's probably not needed
/*
repeat(numvertexes) {
    vertexes[temp,VERTX] = 0;
    vertexes[temp,VERTY] = 0;
    ++temp;
}

temp = 0;

repeat(numvertexes) {
    textures[temp]    = BADFLAT;
    tex_desired[temp] = BADFLAT;
    ++temp;
}

tex_top = BADFLAT;
tex_bot = BADFLAT;
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw the subsector.

//don't draw if we are most likely totally behind the far clip plane
if(point_distance(player.x,player.y, x, y) &gt; SUBSECTOR_MAX_CLIPDIST) exit;

//else, actually draw it
else {
    var hr,vr;    //horiz and vert repeat values for walls
    var thr, tvr; //same, but for flats
    
    temp = 0;   //we can never be sure this var doesn't contain a value
    
    d3d_transform_set_identity();   /////begin identity/////

    repeat(numvertexes) {

        if(temp &lt; numvertexes) {
        
        //determine UVs
        hr = point_distance(vertexes[temp,VERTX], vertexes[temp,VERTY],
                            vertexes[temp+1,VERTX], vertexes[temp+1,VERTY]) / background_get_width(textures[temp]);

        vr = (z2 - z1) / background_get_height(textures[temp]);
        
            //draw the surface
            d3d_draw_wall(
            vertexes[temp,VERTX], vertexes[temp,VERTY], z1,
            vertexes[temp+1,VERTX], vertexes[temp+1,VERTY], z2,
            background_get_texture(textures[temp]), hr, vr);
        
        }   //if
        
        else if(temp == numvertexes) {  //NOTE: this may be miscalculated. try numvertexes-1 if we get out of bounds errors

            //determine UVs
            hr = point_distance(vertexes[temp,VERTX], vertexes[temp,VERTY],
                                vertexes[0,VERTX], vertexes[0,VERTY]) / background_get_width(texture);
    
            vr = (z2 - z1) / background_get_height(texture);
            
                //draw the surface
                d3d_draw_wall(
                vertexes[temp,VERTX], vertexes[temp,VERTY], z1,
                vertexes[0,VERTX], vertexes[0,VERTY], z2,
                background_get_texture(textures[temp]), hr, vr);
        } //else
        
        else {
            I_Quit("Renderer: miscounted vertexes in subsector");
        } //else
    
    ++temp;

    }   //repeat
    
    temp = 0;

    ///////////////////////////////
    /////start floor primitive/////
    d3d_primitive_begin_texture(pr_trianglefan, background_get_texture(tex_top));

    repeat(numvertexes) {
        thr = vertexes[temp,VERTX] / background_get_width(textures[temp]);
        tvr = vertexes[temp,VERTY] / background_get_height(textures[temp]);
        d3d_vertex_texture(vertexes[temp,VERTX], vertexes[temp,VERTY], z2, thr, tvr);
        ++temp;
    }   //repeat
    
    d3d_primitive_end();
    /////end floor primitive/////
    /////////////////////////////

    /////////////////////////////////
    /////start ceiling primitive/////
    if(!global.skyenabled) {

        d3d_primitive_begin_texture(pr_trianglefan, background_get_texture(tex_top));

        repeat(numvertexes) {
            thr = vertexes[temp,VERTX] / background_get_width(textures[temp]);
            tvr = vertexes[temp,VERTY] / background_get_height(textures[temp]);
            d3d_vertex_texture(vertexes[temp,VERTX], vertexes[temp,VERTY], z2, thr, tvr);
            ++temp;
        }   //repeat

        d3d_primitive_end();

    }
    /////end ceiling primitive/////
    ///////////////////////////////

    d3d_transform_set_identity();   /////end identity/////

} //else
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
